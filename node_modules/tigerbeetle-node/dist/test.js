"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const assert_1 = __importDefault(require("assert"));
const _1 = require(".");
const client = (0, _1.createClient)({
    cluster_id: 0n,
    replica_addresses: [process.env.TB_ADDRESS || '3000']
});
const accountA = {
    id: 17n,
    debits_pending: 0n,
    debits_posted: 0n,
    credits_pending: 0n,
    credits_posted: 0n,
    user_data_128: 0n,
    user_data_64: 0n,
    user_data_32: 0,
    reserved: 0,
    ledger: 1,
    code: 718,
    flags: 0,
    timestamp: 0n
};
const accountB = {
    id: 19n,
    debits_pending: 0n,
    debits_posted: 0n,
    credits_pending: 0n,
    credits_posted: 0n,
    user_data_128: 0n,
    user_data_64: 0n,
    user_data_32: 0,
    reserved: 0,
    ledger: 1,
    code: 719,
    flags: 0,
    timestamp: 0n
};
const tests = [];
function test(name, fn) {
    tests.push({ name, fn });
}
test.skip = (name, fn) => {
    console.log(name + ': SKIPPED');
};
test('id() monotonically increasing', async () => {
    let idA = (0, _1.id)();
    for (let i = 0; i < 10000000; i++) {
        if (i % 10000 == 0) {
            await new Promise(resolve => setTimeout(resolve, 1));
        }
        const idB = (0, _1.id)();
        assert_1.default.ok(idB > idA, 'id() returned an id that did not monotonically increase');
        idA = idB;
    }
});
test('range check `code` on Account to be u16', async () => {
    const account = { ...accountA, id: 0n };
    account.code = 65535 + 1;
    const codeError = await client.createAccounts([account]).catch(error => error);
    assert_1.default.strictEqual(codeError.message, 'code must be a u16.');
    const accounts = await client.lookupAccounts([account.id]);
    assert_1.default.deepStrictEqual(accounts, []);
});
test('can create accounts', async () => {
    const errors = await client.createAccounts([accountA]);
    assert_1.default.deepStrictEqual(errors, []);
});
test('can return error on account', async () => {
    const errors = await client.createAccounts([accountA, accountB]);
    assert_1.default.strictEqual(errors.length, 1);
    assert_1.default.deepStrictEqual(errors[0], { index: 0, result: _1.CreateAccountError.exists });
});
test('error if timestamp is not set to 0n on account', async () => {
    const account = { ...accountA, timestamp: 2n, id: 3n };
    const errors = await client.createAccounts([account]);
    assert_1.default.strictEqual(errors.length, 1);
    assert_1.default.deepStrictEqual(errors[0], { index: 0, result: _1.CreateAccountError.timestamp_must_be_zero });
});
test('can lookup accounts', async () => {
    const accounts = await client.lookupAccounts([accountA.id, accountB.id]);
    assert_1.default.strictEqual(accounts.length, 2);
    const account1 = accounts[0];
    assert_1.default.strictEqual(account1.id, 17n);
    assert_1.default.strictEqual(account1.credits_posted, 0n);
    assert_1.default.strictEqual(account1.credits_pending, 0n);
    assert_1.default.strictEqual(account1.debits_posted, 0n);
    assert_1.default.strictEqual(account1.debits_pending, 0n);
    assert_1.default.strictEqual(account1.user_data_128, 0n);
    assert_1.default.strictEqual(account1.user_data_64, 0n);
    assert_1.default.strictEqual(account1.user_data_32, 0);
    assert_1.default.strictEqual(account1.code, 718);
    assert_1.default.strictEqual(account1.ledger, 1);
    assert_1.default.strictEqual(account1.flags, 0);
    assert_1.default.ok(account1.timestamp > 0n);
    const account2 = accounts[1];
    assert_1.default.strictEqual(account2.id, 19n);
    assert_1.default.strictEqual(account2.credits_posted, 0n);
    assert_1.default.strictEqual(account2.credits_pending, 0n);
    assert_1.default.strictEqual(account2.debits_posted, 0n);
    assert_1.default.strictEqual(account2.debits_pending, 0n);
    assert_1.default.strictEqual(account2.user_data_128, 0n);
    assert_1.default.strictEqual(account2.user_data_64, 0n);
    assert_1.default.strictEqual(account2.user_data_32, 0);
    assert_1.default.strictEqual(account2.code, 719);
    assert_1.default.strictEqual(account2.ledger, 1);
    assert_1.default.strictEqual(account2.flags, 0);
    assert_1.default.ok(account2.timestamp > 0n);
});
test('can create a transfer', async () => {
    const transfer = {
        id: 1n,
        debit_account_id: accountB.id,
        credit_account_id: accountA.id,
        amount: 100n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        pending_id: 0n,
        timeout: 0,
        ledger: 1,
        code: 1,
        flags: 0,
        timestamp: 0n,
    };
    const errors = await client.createTransfers([transfer]);
    assert_1.default.deepStrictEqual(errors, []);
    const accounts = await client.lookupAccounts([accountA.id, accountB.id]);
    assert_1.default.strictEqual(accounts.length, 2);
    assert_1.default.strictEqual(accounts[0].credits_posted, 100n);
    assert_1.default.strictEqual(accounts[0].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[0].debits_posted, 0n);
    assert_1.default.strictEqual(accounts[0].debits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].credits_posted, 0n);
    assert_1.default.strictEqual(accounts[1].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].debits_posted, 100n);
    assert_1.default.strictEqual(accounts[1].debits_pending, 0n);
});
test('can create a two-phase transfer', async () => {
    let flags = 0;
    flags |= _1.TransferFlags.pending;
    const transfer = {
        id: 2n,
        debit_account_id: accountB.id,
        credit_account_id: accountA.id,
        amount: 50n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        pending_id: 0n,
        timeout: 2e9,
        ledger: 1,
        code: 1,
        flags,
        timestamp: 0n,
    };
    const errors = await client.createTransfers([transfer]);
    assert_1.default.deepStrictEqual(errors, []);
    const accounts = await client.lookupAccounts([accountA.id, accountB.id]);
    assert_1.default.strictEqual(accounts.length, 2);
    assert_1.default.strictEqual(accounts[0].credits_posted, 100n);
    assert_1.default.strictEqual(accounts[0].credits_pending, 50n);
    assert_1.default.strictEqual(accounts[0].debits_posted, 0n);
    assert_1.default.strictEqual(accounts[0].debits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].credits_posted, 0n);
    assert_1.default.strictEqual(accounts[1].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].debits_posted, 100n);
    assert_1.default.strictEqual(accounts[1].debits_pending, 50n);
    const transfers = await client.lookupTransfers([transfer.id]);
    assert_1.default.strictEqual(transfers.length, 1);
    assert_1.default.strictEqual(transfers[0].id, 2n);
    assert_1.default.strictEqual(transfers[0].debit_account_id, accountB.id);
    assert_1.default.strictEqual(transfers[0].credit_account_id, accountA.id);
    assert_1.default.strictEqual(transfers[0].amount, 50n);
    assert_1.default.strictEqual(transfers[0].user_data_128, 0n);
    assert_1.default.strictEqual(transfers[0].user_data_64, 0n);
    assert_1.default.strictEqual(transfers[0].user_data_32, 0);
    assert_1.default.strictEqual(transfers[0].timeout > 0, true);
    assert_1.default.strictEqual(transfers[0].code, 1);
    assert_1.default.strictEqual(transfers[0].flags, 2);
    assert_1.default.strictEqual(transfers[0].timestamp > 0, true);
});
test('can post a two-phase transfer', async () => {
    let flags = 0;
    flags |= _1.TransferFlags.post_pending_transfer;
    const commit = {
        id: 3n,
        debit_account_id: BigInt(0),
        credit_account_id: BigInt(0),
        amount: _1.amount_max,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        pending_id: 2n,
        timeout: 0,
        ledger: 1,
        code: 1,
        flags: flags,
        timestamp: 0n,
    };
    const errors = await client.createTransfers([commit]);
    assert_1.default.deepStrictEqual(errors, []);
    const accounts = await client.lookupAccounts([accountA.id, accountB.id]);
    assert_1.default.strictEqual(accounts.length, 2);
    assert_1.default.strictEqual(accounts[0].credits_posted, 150n);
    assert_1.default.strictEqual(accounts[0].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[0].debits_posted, 0n);
    assert_1.default.strictEqual(accounts[0].debits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].credits_posted, 0n);
    assert_1.default.strictEqual(accounts[1].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].debits_posted, 150n);
    assert_1.default.strictEqual(accounts[1].debits_pending, 0n);
});
test('can reject a two-phase transfer', async () => {
    const transfer = {
        id: 4n,
        debit_account_id: accountB.id,
        credit_account_id: accountA.id,
        amount: 50n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        pending_id: 0n,
        timeout: 1e9,
        ledger: 1,
        code: 1,
        flags: _1.TransferFlags.pending,
        timestamp: 0n,
    };
    const transferErrors = await client.createTransfers([transfer]);
    assert_1.default.deepStrictEqual(transferErrors, []);
    const reject = {
        id: 5n,
        debit_account_id: BigInt(0),
        credit_account_id: BigInt(0),
        amount: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        pending_id: 4n,
        timeout: 0,
        ledger: 1,
        code: 1,
        flags: _1.TransferFlags.void_pending_transfer,
        timestamp: 0n,
    };
    const errors = await client.createTransfers([reject]);
    assert_1.default.deepStrictEqual(errors, []);
    const accounts = await client.lookupAccounts([accountA.id, accountB.id]);
    assert_1.default.strictEqual(accounts.length, 2);
    assert_1.default.strictEqual(accounts[0].credits_posted, 150n);
    assert_1.default.strictEqual(accounts[0].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[0].debits_posted, 0n);
    assert_1.default.strictEqual(accounts[0].debits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].credits_posted, 0n);
    assert_1.default.strictEqual(accounts[1].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].debits_posted, 150n);
    assert_1.default.strictEqual(accounts[1].debits_pending, 0n);
});
test('can link transfers', async () => {
    const transfer1 = {
        id: 6n,
        debit_account_id: accountB.id,
        credit_account_id: accountA.id,
        amount: 100n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        pending_id: 0n,
        timeout: 0,
        ledger: 1,
        code: 1,
        flags: _1.TransferFlags.linked,
        timestamp: 0n,
    };
    const transfer2 = {
        id: 6n,
        debit_account_id: accountB.id,
        credit_account_id: accountA.id,
        amount: 100n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        pending_id: 0n,
        timeout: 0,
        ledger: 1,
        code: 1,
        flags: 0,
        timestamp: 0n,
    };
    const errors = await client.createTransfers([transfer1, transfer2]);
    assert_1.default.strictEqual(errors.length, 2);
    assert_1.default.deepStrictEqual(errors[0], { index: 0, result: _1.CreateTransferError.linked_event_failed });
    assert_1.default.deepStrictEqual(errors[1], { index: 1, result: _1.CreateTransferError.exists_with_different_flags });
    const accounts = await client.lookupAccounts([accountA.id, accountB.id]);
    assert_1.default.strictEqual(accounts.length, 2);
    assert_1.default.strictEqual(accounts[0].credits_posted, 150n);
    assert_1.default.strictEqual(accounts[0].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[0].debits_posted, 0n);
    assert_1.default.strictEqual(accounts[0].debits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].credits_posted, 0n);
    assert_1.default.strictEqual(accounts[1].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].debits_posted, 150n);
    assert_1.default.strictEqual(accounts[1].debits_pending, 0n);
});
test('cannot void an expired transfer', async () => {
    const transfer = {
        id: 6n,
        debit_account_id: accountB.id,
        credit_account_id: accountA.id,
        amount: 50n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        pending_id: 0n,
        timeout: 1,
        ledger: 1,
        code: 1,
        flags: _1.TransferFlags.pending,
        timestamp: 0n,
    };
    const transferErrors = await client.createTransfers([transfer]);
    assert_1.default.deepStrictEqual(transferErrors, []);
    var accounts = await client.lookupAccounts([accountA.id, accountB.id]);
    assert_1.default.strictEqual(accounts.length, 2);
    assert_1.default.strictEqual(accounts[0].credits_posted, 150n);
    assert_1.default.strictEqual(accounts[0].credits_pending, 50n);
    assert_1.default.strictEqual(accounts[0].debits_posted, 0n);
    assert_1.default.strictEqual(accounts[0].debits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].credits_posted, 0n);
    assert_1.default.strictEqual(accounts[1].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].debits_posted, 150n);
    assert_1.default.strictEqual(accounts[1].debits_pending, 50n);
    const extra_wait_time = 250;
    await new Promise(_ => setTimeout(_, (transfer.timeout * 1000) + extra_wait_time));
    accounts = await client.lookupAccounts([accountA.id, accountB.id]);
    assert_1.default.strictEqual(accounts.length, 2);
    assert_1.default.strictEqual(accounts[0].credits_posted, 150n);
    assert_1.default.strictEqual(accounts[0].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[0].debits_posted, 0n);
    assert_1.default.strictEqual(accounts[0].debits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].credits_posted, 0n);
    assert_1.default.strictEqual(accounts[1].credits_pending, 0n);
    assert_1.default.strictEqual(accounts[1].debits_posted, 150n);
    assert_1.default.strictEqual(accounts[1].debits_pending, 0n);
    const reject = {
        id: 7n,
        debit_account_id: BigInt(0),
        credit_account_id: BigInt(0),
        amount: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        pending_id: 6n,
        timeout: 0,
        ledger: 1,
        code: 1,
        flags: _1.TransferFlags.void_pending_transfer,
        timestamp: 0n,
    };
    const errors = await client.createTransfers([reject]);
    assert_1.default.strictEqual(errors.length, 1);
    assert_1.default.deepStrictEqual(errors[0], { index: 0, result: _1.CreateTransferError.pending_transfer_expired });
});
test('can close accounts', async () => {
    const closing_transfer = {
        id: (0, _1.id)(),
        debit_account_id: accountB.id,
        credit_account_id: accountA.id,
        amount: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        pending_id: 0n,
        timeout: 0,
        ledger: 1,
        code: 1,
        flags: _1.TransferFlags.closing_debit | _1.TransferFlags.closing_credit | _1.TransferFlags.pending,
        timestamp: 0n,
    };
    let errors = await client.createTransfers([closing_transfer]);
    assert_1.default.strictEqual(errors.length, 0);
    let accounts = await client.lookupAccounts([accountA.id, accountB.id]);
    assert_1.default.strictEqual(accounts.length, 2);
    assert_1.default.ok(accountA.flags != accounts[0].flags);
    assert_1.default.ok((accounts[0].flags & _1.AccountFlags.closed) != 0);
    assert_1.default.ok(accountB.flags != accounts[1].flags);
    assert_1.default.ok((accounts[1].flags & _1.AccountFlags.closed) != 0);
    const voiding_transfer = {
        id: (0, _1.id)(),
        debit_account_id: accountB.id,
        credit_account_id: accountA.id,
        amount: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        timeout: 0,
        ledger: 1,
        code: 1,
        flags: _1.TransferFlags.void_pending_transfer,
        pending_id: closing_transfer.id,
        timestamp: 0n,
    };
    errors = await client.createTransfers([voiding_transfer]);
    assert_1.default.strictEqual(errors.length, 0);
    accounts = await client.lookupAccounts([accountA.id, accountB.id]);
    assert_1.default.strictEqual(accounts.length, 2);
    assert_1.default.strictEqual(accountA.flags, accounts[0].flags);
    assert_1.default.ok((accounts[0].flags & _1.AccountFlags.closed) == 0);
    assert_1.default.strictEqual(accountB.flags, accounts[1].flags);
    assert_1.default.ok((accounts[1].flags & _1.AccountFlags.closed) == 0);
});
test('can get account transfers', async () => {
    const accountC = {
        id: 21n,
        debits_pending: 0n,
        debits_posted: 0n,
        credits_pending: 0n,
        credits_posted: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        reserved: 0,
        ledger: 1,
        code: 718,
        flags: _1.AccountFlags.history,
        timestamp: 0n
    };
    const account_errors = await client.createAccounts([accountC]);
    assert_1.default.deepStrictEqual(account_errors, []);
    var transfers_created = [];
    for (var i = 0; i < 10; i++) {
        transfers_created.push({
            id: BigInt(i + 10000),
            debit_account_id: i % 2 == 0 ? accountC.id : accountA.id,
            credit_account_id: i % 2 == 0 ? accountB.id : accountC.id,
            amount: 100n,
            user_data_128: 0n,
            user_data_64: 0n,
            user_data_32: 0,
            pending_id: 0n,
            timeout: 0,
            ledger: 1,
            code: 1,
            flags: 0,
            timestamp: 0n,
        });
    }
    const transfers_created_result = await client.createTransfers(transfers_created);
    assert_1.default.deepStrictEqual(transfers_created_result, []);
    var filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 8190,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits,
    };
    var transfers = await client.getAccountTransfers(filter);
    var account_balances = await client.getAccountBalances(filter);
    assert_1.default.strictEqual(transfers.length, transfers_created.length);
    assert_1.default.strictEqual(account_balances.length, transfers.length);
    var timestamp = 0n;
    var i = 0;
    for (var transfer of transfers) {
        assert_1.default.ok(timestamp < transfer.timestamp);
        timestamp = transfer.timestamp;
        assert_1.default.ok(account_balances[i].timestamp == transfer.timestamp);
        i++;
    }
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 8190,
        flags: _1.AccountFilterFlags.debits | _1.AccountFilterFlags.reversed,
    };
    transfers = await client.getAccountTransfers(filter);
    account_balances = await client.getAccountBalances(filter);
    assert_1.default.strictEqual(transfers.length, transfers_created.length / 2);
    assert_1.default.strictEqual(account_balances.length, transfers.length);
    timestamp = 1n << 64n;
    i = 0;
    for (var transfer of transfers) {
        assert_1.default.ok(transfer.timestamp < timestamp);
        timestamp = transfer.timestamp;
        assert_1.default.ok(account_balances[i].timestamp == transfer.timestamp);
        i++;
    }
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 8190,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.reversed,
    };
    transfers = await client.getAccountTransfers(filter);
    account_balances = await client.getAccountBalances(filter);
    assert_1.default.strictEqual(transfers.length, transfers_created.length / 2);
    assert_1.default.strictEqual(account_balances.length, transfers.length);
    timestamp = 1n << 64n;
    i = 0;
    for (var transfer of transfers) {
        assert_1.default.ok(transfer.timestamp < timestamp);
        timestamp = transfer.timestamp;
        assert_1.default.ok(account_balances[i].timestamp == transfer.timestamp);
        i++;
    }
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: transfers_created.length / 2,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits,
    };
    transfers = await client.getAccountTransfers(filter);
    account_balances = await client.getAccountBalances(filter);
    assert_1.default.strictEqual(transfers.length, transfers_created.length / 2);
    assert_1.default.strictEqual(account_balances.length, transfers.length);
    timestamp = 0n;
    i = 0;
    for (var transfer of transfers) {
        assert_1.default.ok(timestamp < transfer.timestamp);
        timestamp = transfer.timestamp;
        assert_1.default.ok(account_balances[i].timestamp == transfer.timestamp);
        i++;
    }
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: timestamp + 1n,
        timestamp_max: 0n,
        limit: transfers_created.length / 2,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits,
    };
    transfers = await client.getAccountTransfers(filter);
    account_balances = await client.getAccountBalances(filter);
    assert_1.default.strictEqual(transfers.length, transfers_created.length / 2);
    assert_1.default.strictEqual(account_balances.length, transfers.length);
    i = 0;
    for (var transfer of transfers) {
        assert_1.default.ok(timestamp < transfer.timestamp);
        timestamp = transfer.timestamp;
        assert_1.default.ok(account_balances[i].timestamp == transfer.timestamp);
        i++;
    }
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: timestamp + 1n,
        timestamp_max: 0n,
        limit: transfers_created.length / 2,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits,
    };
    transfers = await client.getAccountTransfers(filter);
    account_balances = await client.getAccountBalances(filter);
    assert_1.default.deepStrictEqual(transfers, []);
    assert_1.default.strictEqual(account_balances.length, transfers.length);
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: transfers_created.length / 2,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits | _1.AccountFilterFlags.reversed,
    };
    transfers = await client.getAccountTransfers(filter);
    account_balances = await client.getAccountBalances(filter);
    assert_1.default.strictEqual(transfers.length, transfers_created.length / 2);
    assert_1.default.strictEqual(account_balances.length, transfers.length);
    timestamp = 1n << 64n;
    i = 0;
    for (var transfer of transfers) {
        assert_1.default.ok(timestamp > transfer.timestamp);
        timestamp = transfer.timestamp;
        assert_1.default.ok(account_balances[i].timestamp == transfer.timestamp);
        i++;
    }
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: timestamp - 1n,
        limit: transfers_created.length / 2,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits | _1.AccountFilterFlags.reversed,
    };
    transfers = await client.getAccountTransfers(filter);
    account_balances = await client.getAccountBalances(filter);
    assert_1.default.strictEqual(transfers.length, transfers_created.length / 2);
    assert_1.default.strictEqual(account_balances.length, transfers.length);
    i = 0;
    for (var transfer of transfers) {
        assert_1.default.ok(timestamp > transfer.timestamp);
        timestamp = transfer.timestamp;
        assert_1.default.ok(account_balances[i].timestamp == transfer.timestamp);
        i++;
    }
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: timestamp - 1n,
        limit: transfers_created.length / 2,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits | _1.AccountFilterFlags.reversed,
    };
    transfers = await client.getAccountTransfers(filter);
    account_balances = await client.getAccountBalances(filter);
    assert_1.default.deepStrictEqual(transfers, []);
    assert_1.default.strictEqual(account_balances.length, transfers.length);
    filter = {
        account_id: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 8190,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits,
    };
    assert_1.default.deepStrictEqual((await client.getAccountTransfers(filter)), []);
    assert_1.default.deepStrictEqual((await client.getAccountBalances(filter)), []);
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: (1n << 64n) - 1n,
        timestamp_max: 0n,
        limit: 8190,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits,
    };
    assert_1.default.deepStrictEqual((await client.getAccountTransfers(filter)), []);
    assert_1.default.deepStrictEqual((await client.getAccountBalances(filter)), []);
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: (1n << 64n) - 1n,
        limit: 8190,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits,
    };
    assert_1.default.deepStrictEqual((await client.getAccountTransfers(filter)), []);
    assert_1.default.deepStrictEqual((await client.getAccountBalances(filter)), []);
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: (1n << 64n) - 2n,
        timestamp_max: 1n,
        limit: 8190,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits,
    };
    assert_1.default.deepStrictEqual((await client.getAccountTransfers(filter)), []);
    assert_1.default.deepStrictEqual((await client.getAccountBalances(filter)), []);
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 0,
        flags: _1.AccountFilterFlags.credits | _1.AccountFilterFlags.debits,
    };
    assert_1.default.deepStrictEqual((await client.getAccountTransfers(filter)), []);
    assert_1.default.deepStrictEqual((await client.getAccountBalances(filter)), []);
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 8190,
        flags: _1.AccountFilterFlags.none,
    };
    assert_1.default.deepStrictEqual((await client.getAccountTransfers(filter)), []);
    assert_1.default.deepStrictEqual((await client.getAccountBalances(filter)), []);
    filter = {
        account_id: accountC.id,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 8190,
        flags: 0xFFFF,
    };
    assert_1.default.deepStrictEqual((await client.getAccountTransfers(filter)), []);
    assert_1.default.deepStrictEqual((await client.getAccountBalances(filter)), []);
});
test('can query accounts', async () => {
    {
        var accounts = [];
        for (var i = 0; i < 10; i++) {
            accounts.push({
                id: (0, _1.id)(),
                debits_pending: 0n,
                debits_posted: 0n,
                credits_pending: 0n,
                credits_posted: 0n,
                user_data_128: i % 2 == 0 ? 1000n : 2000n,
                user_data_64: i % 2 == 0 ? 100n : 200n,
                user_data_32: i % 2 == 0 ? 10 : 20,
                ledger: 1,
                code: 999,
                flags: _1.AccountFlags.none,
                reserved: 0,
                timestamp: 0n,
            });
        }
        const create_accounts_result = await client.createAccounts(accounts);
        assert_1.default.deepStrictEqual(create_accounts_result, []);
    }
    {
        var filter = {
            user_data_128: 1000n,
            user_data_64: 100n,
            user_data_32: 10,
            ledger: 1,
            code: 999,
            timestamp_min: 0n,
            timestamp_max: 0n,
            limit: 8190,
            flags: _1.QueryFilterFlags.none,
        };
        var query = await client.queryAccounts(filter);
        assert_1.default.strictEqual(query.length, 5);
        var timestamp = 0n;
        for (var account of query) {
            assert_1.default.ok(timestamp < account.timestamp);
            timestamp = account.timestamp;
            assert_1.default.strictEqual(account.user_data_128, filter.user_data_128);
            assert_1.default.strictEqual(account.user_data_64, filter.user_data_64);
            assert_1.default.strictEqual(account.user_data_32, filter.user_data_32);
            assert_1.default.strictEqual(account.ledger, filter.ledger);
            assert_1.default.strictEqual(account.code, filter.code);
        }
    }
    {
        var filter = {
            user_data_128: 2000n,
            user_data_64: 200n,
            user_data_32: 20,
            ledger: 1,
            code: 999,
            timestamp_min: 0n,
            timestamp_max: 0n,
            limit: 8190,
            flags: _1.QueryFilterFlags.reversed,
        };
        var query = await client.queryAccounts(filter);
        assert_1.default.strictEqual(query.length, 5);
        var timestamp = 1n << 64n;
        for (var account of query) {
            assert_1.default.ok(timestamp > account.timestamp);
            timestamp = account.timestamp;
            assert_1.default.strictEqual(account.user_data_128, filter.user_data_128);
            assert_1.default.strictEqual(account.user_data_64, filter.user_data_64);
            assert_1.default.strictEqual(account.user_data_32, filter.user_data_32);
            assert_1.default.strictEqual(account.ledger, filter.ledger);
            assert_1.default.strictEqual(account.code, filter.code);
        }
    }
    {
        var filter = {
            user_data_128: 0n,
            user_data_64: 0n,
            user_data_32: 0,
            ledger: 0,
            code: 999,
            timestamp_min: 0n,
            timestamp_max: 0n,
            limit: 8190,
            flags: _1.QueryFilterFlags.none,
        };
        var query = await client.queryAccounts(filter);
        assert_1.default.strictEqual(query.length, 10);
        var timestamp = 0n;
        for (var account of query) {
            assert_1.default.ok(timestamp < account.timestamp);
            timestamp = account.timestamp;
            assert_1.default.strictEqual(account.code, filter.code);
        }
    }
    {
        var filter = {
            user_data_128: 0n,
            user_data_64: 0n,
            user_data_32: 0,
            ledger: 0,
            code: 999,
            timestamp_min: 0n,
            timestamp_max: 0n,
            limit: 5,
            flags: _1.QueryFilterFlags.reversed,
        };
        var query = await client.queryAccounts(filter);
        assert_1.default.strictEqual(query.length, 5);
        var timestamp = 1n << 64n;
        for (var account of query) {
            assert_1.default.ok(timestamp > account.timestamp);
            timestamp = account.timestamp;
            assert_1.default.strictEqual(account.code, filter.code);
        }
        filter.timestamp_max = timestamp - 1n;
        query = await client.queryAccounts(filter);
        assert_1.default.strictEqual(query.length, 5);
        for (var account of query) {
            assert_1.default.ok(timestamp > account.timestamp);
            timestamp = account.timestamp;
            assert_1.default.strictEqual(account.code, filter.code);
        }
        filter.timestamp_max = timestamp - 1n;
        query = await client.queryAccounts(filter);
        assert_1.default.strictEqual(query.length, 0);
    }
    {
        var filter = {
            user_data_128: 0n,
            user_data_64: 200n,
            user_data_32: 10,
            ledger: 0,
            code: 0,
            timestamp_min: 0n,
            timestamp_max: 0n,
            limit: 8190,
            flags: _1.QueryFilterFlags.none,
        };
        var query = await client.queryAccounts(filter);
        assert_1.default.strictEqual(query.length, 0);
    }
});
test('can query transfers', async () => {
    {
        const account = {
            id: (0, _1.id)(),
            debits_pending: 0n,
            debits_posted: 0n,
            credits_pending: 0n,
            credits_posted: 0n,
            user_data_128: 0n,
            user_data_64: 0n,
            user_data_32: 0,
            reserved: 0,
            ledger: 1,
            code: 718,
            flags: _1.AccountFlags.none,
            timestamp: 0n
        };
        const create_accounts_result = await client.createAccounts([account]);
        assert_1.default.deepStrictEqual(create_accounts_result, []);
        var transfers_created = [];
        for (var i = 0; i < 10; i++) {
            transfers_created.push({
                id: (0, _1.id)(),
                debit_account_id: i % 2 == 0 ? account.id : accountA.id,
                credit_account_id: i % 2 == 0 ? accountB.id : account.id,
                amount: 100n,
                user_data_128: i % 2 == 0 ? 1000n : 2000n,
                user_data_64: i % 2 == 0 ? 100n : 200n,
                user_data_32: i % 2 == 0 ? 10 : 20,
                pending_id: 0n,
                timeout: 0,
                ledger: 1,
                code: 999,
                flags: 0,
                timestamp: 0n,
            });
        }
        const create_transfers_result = await client.createTransfers(transfers_created);
        assert_1.default.deepStrictEqual(create_transfers_result, []);
    }
    {
        var filter = {
            user_data_128: 1000n,
            user_data_64: 100n,
            user_data_32: 10,
            ledger: 1,
            code: 999,
            timestamp_min: 0n,
            timestamp_max: 0n,
            limit: 8190,
            flags: _1.QueryFilterFlags.none,
        };
        var query = await client.queryTransfers(filter);
        assert_1.default.strictEqual(query.length, 5);
        var timestamp = 0n;
        for (var transfer of query) {
            assert_1.default.ok(timestamp < transfer.timestamp);
            timestamp = transfer.timestamp;
            assert_1.default.strictEqual(transfer.user_data_128, filter.user_data_128);
            assert_1.default.strictEqual(transfer.user_data_64, filter.user_data_64);
            assert_1.default.strictEqual(transfer.user_data_32, filter.user_data_32);
            assert_1.default.strictEqual(transfer.ledger, filter.ledger);
            assert_1.default.strictEqual(transfer.code, filter.code);
        }
    }
    {
        var filter = {
            user_data_128: 2000n,
            user_data_64: 200n,
            user_data_32: 20,
            ledger: 1,
            code: 999,
            timestamp_min: 0n,
            timestamp_max: 0n,
            limit: 8190,
            flags: _1.QueryFilterFlags.reversed,
        };
        var query = await client.queryTransfers(filter);
        assert_1.default.strictEqual(query.length, 5);
        var timestamp = 1n << 64n;
        for (var transfer of query) {
            assert_1.default.ok(timestamp > transfer.timestamp);
            timestamp = transfer.timestamp;
            assert_1.default.strictEqual(transfer.user_data_128, filter.user_data_128);
            assert_1.default.strictEqual(transfer.user_data_64, filter.user_data_64);
            assert_1.default.strictEqual(transfer.user_data_32, filter.user_data_32);
            assert_1.default.strictEqual(transfer.ledger, filter.ledger);
            assert_1.default.strictEqual(transfer.code, filter.code);
        }
    }
    {
        var filter = {
            user_data_128: 0n,
            user_data_64: 0n,
            user_data_32: 0,
            ledger: 0,
            code: 999,
            timestamp_min: 0n,
            timestamp_max: 0n,
            limit: 8190,
            flags: _1.QueryFilterFlags.none,
        };
        var query = await client.queryTransfers(filter);
        assert_1.default.strictEqual(query.length, 10);
        var timestamp = 0n;
        for (var transfer of query) {
            assert_1.default.ok(timestamp < transfer.timestamp);
            timestamp = transfer.timestamp;
            assert_1.default.strictEqual(transfer.code, filter.code);
        }
    }
    {
        var filter = {
            user_data_128: 0n,
            user_data_64: 0n,
            user_data_32: 0,
            ledger: 0,
            code: 999,
            timestamp_min: 0n,
            timestamp_max: 0n,
            limit: 5,
            flags: _1.QueryFilterFlags.reversed,
        };
        var query = await client.queryTransfers(filter);
        assert_1.default.strictEqual(query.length, 5);
        var timestamp = 1n << 64n;
        for (var transfer of query) {
            assert_1.default.ok(timestamp > transfer.timestamp);
            timestamp = transfer.timestamp;
            assert_1.default.strictEqual(transfer.code, filter.code);
        }
        filter.timestamp_max = timestamp - 1n;
        query = await client.queryTransfers(filter);
        assert_1.default.strictEqual(query.length, 5);
        for (var transfer of query) {
            assert_1.default.ok(timestamp > transfer.timestamp);
            timestamp = transfer.timestamp;
            assert_1.default.strictEqual(transfer.code, filter.code);
        }
        filter.timestamp_max = timestamp - 1n;
        query = await client.queryTransfers(filter);
        assert_1.default.strictEqual(query.length, 0);
    }
    {
        var filter = {
            user_data_128: 0n,
            user_data_64: 200n,
            user_data_32: 10,
            ledger: 0,
            code: 0,
            timestamp_min: 0n,
            timestamp_max: 0n,
            limit: 8190,
            flags: _1.QueryFilterFlags.none,
        };
        var query = await client.queryTransfers(filter);
        assert_1.default.strictEqual(query.length, 0);
    }
});
test('query with invalid filter', async () => {
    var filter = {
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        ledger: 0,
        code: 0,
        timestamp_min: (1n << 64n) - 1n,
        timestamp_max: 0n,
        limit: 8190,
        flags: _1.QueryFilterFlags.none,
    };
    assert_1.default.deepStrictEqual((await client.queryAccounts(filter)), []);
    assert_1.default.deepStrictEqual((await client.queryTransfers(filter)), []);
    filter = {
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        ledger: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: (1n << 64n) - 1n,
        limit: 8190,
        flags: _1.QueryFilterFlags.none,
    };
    assert_1.default.deepStrictEqual((await client.queryAccounts(filter)), []);
    assert_1.default.deepStrictEqual((await client.queryTransfers(filter)), []);
    filter = {
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        ledger: 0,
        code: 0,
        timestamp_min: (1n << 64n) - 2n,
        timestamp_max: 1n,
        limit: 8190,
        flags: _1.QueryFilterFlags.none,
    };
    assert_1.default.deepStrictEqual((await client.queryAccounts(filter)), []);
    assert_1.default.deepStrictEqual((await client.queryTransfers(filter)), []);
    filter = {
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        ledger: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 0,
        flags: _1.QueryFilterFlags.none,
    };
    assert_1.default.deepStrictEqual((await client.queryAccounts(filter)), []);
    assert_1.default.deepStrictEqual((await client.queryTransfers(filter)), []);
    filter = {
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        ledger: 0,
        code: 0,
        timestamp_min: 0n,
        timestamp_max: 0n,
        limit: 0,
        flags: 0xFFFF,
    };
    assert_1.default.deepStrictEqual((await client.queryAccounts(filter)), []);
    assert_1.default.deepStrictEqual((await client.queryTransfers(filter)), []);
});
test('can import accounts and transfers', async () => {
    const accountTmp = {
        id: (0, _1.id)(),
        debits_pending: 0n,
        debits_posted: 0n,
        credits_pending: 0n,
        credits_posted: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        reserved: 0,
        ledger: 1,
        code: 718,
        flags: 0,
        timestamp: 0n
    };
    let accountsErrors = await client.createAccounts([accountTmp]);
    assert_1.default.deepStrictEqual(accountsErrors, []);
    let accountLookup = await client.lookupAccounts([accountTmp.id]);
    assert_1.default.strictEqual(accountLookup.length, 1);
    const timestampMax = accountLookup[0].timestamp;
    await new Promise(_ => setTimeout(_, 10));
    const accountA = {
        id: (0, _1.id)(),
        debits_pending: 0n,
        debits_posted: 0n,
        credits_pending: 0n,
        credits_posted: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        reserved: 0,
        ledger: 1,
        code: 718,
        flags: _1.AccountFlags.imported,
        timestamp: timestampMax + 1n
    };
    const accountB = {
        id: (0, _1.id)(),
        debits_pending: 0n,
        debits_posted: 0n,
        credits_pending: 0n,
        credits_posted: 0n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        reserved: 0,
        ledger: 1,
        code: 718,
        flags: _1.AccountFlags.imported,
        timestamp: timestampMax + 2n
    };
    accountsErrors = await client.createAccounts([accountA, accountB]);
    assert_1.default.deepStrictEqual(accountsErrors, []);
    accountLookup = await client.lookupAccounts([accountA.id, accountB.id]);
    assert_1.default.strictEqual(accountLookup.length, 2);
    assert_1.default.strictEqual(accountLookup[0].timestamp, accountA.timestamp);
    assert_1.default.strictEqual(accountLookup[1].timestamp, accountB.timestamp);
    const transfer = {
        id: (0, _1.id)(),
        debit_account_id: accountA.id,
        credit_account_id: accountB.id,
        amount: 100n,
        user_data_128: 0n,
        user_data_64: 0n,
        user_data_32: 0,
        pending_id: 0n,
        timeout: 0,
        ledger: 1,
        code: 1,
        flags: _1.TransferFlags.imported,
        timestamp: timestampMax + 3n,
    };
    const errors = await client.createTransfers([transfer]);
    assert_1.default.deepStrictEqual(errors, []);
    const transfers = await client.lookupTransfers([transfer.id]);
    assert_1.default.strictEqual(transfers.length, 1);
    assert_1.default.strictEqual(transfers[0].timestamp, timestampMax + 3n);
});
test('accept zero-length create_accounts', async () => {
    const errors = await client.createAccounts([]);
    assert_1.default.deepStrictEqual(errors, []);
});
test('accept zero-length create_transfers', async () => {
    const errors = await client.createTransfers([]);
    assert_1.default.deepStrictEqual(errors, []);
});
test('accept zero-length lookup_accounts', async () => {
    const accounts = await client.lookupAccounts([]);
    assert_1.default.deepStrictEqual(accounts, []);
});
test('accept zero-length lookup_transfers', async () => {
    const transfers = await client.lookupTransfers([]);
    assert_1.default.deepStrictEqual(transfers, []);
});
async function main() {
    const start = new Date().getTime();
    try {
        for (let i = 0; i < tests.length; i++) {
            await tests[i].fn().then(() => {
                console.log(tests[i].name + ": PASSED");
            }).catch(error => {
                console.log(tests[i].name + ": FAILED");
                throw error;
            });
        }
        const end = new Date().getTime();
        console.log('Time taken (s):', (end - start) / 1000);
    }
    finally {
        await client.destroy();
    }
}
main().catch((error) => {
    console.log('operator:', error.operator);
    console.log('stack:', error.stack);
    process.exit(-1);
});
//# sourceMappingURL=test.js.map